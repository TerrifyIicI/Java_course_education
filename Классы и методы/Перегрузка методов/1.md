## Практика 1 — Разница между вызовами в цикле и напрямую

### Код

```java
public class A {
    public void printNum(Integer i) {
        System.out.printf("Integer = %d%n", i);
    }
    public void printNum(int i) {
        System.out.printf("int = %d%n", i);
    }
    public void printNum(Float f) {
        System.out.printf("Float = %.4f%n", f);
    }
    public void printNum(Number n) {
        System.out.println("Number=" + n);
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        Number[] num = {new Integer(1), 11, 1.11f, 11.11};
        
        // цикл for (1)
        for (Number n : num) {
            a.printNum(n);
        }
        
        // (2)
        a.printNum(new Integer(1));
        a.printNum(11);
        a.printNum(1.11f);
        a.printNum(11.11);
    }
}
```

### Вывод

```
Number=1
Number=11
Number=1.11
Number=11.11
Integer = 1
int = 11
Float = 1.1100
Number=11.11
```

### Объяснение

**Перегрузка определяется на этапе компиляции**, а не во время выполнения программы.

**В цикле for (1):**
Переменная `n` имеет тип `Number` (объявлена как `Number n`). Компилятор видит только тип `Number` и выбирает метод `printNum(Number n)` для всех вызовов. Реальный тип объекта в массиве (Integer, Float, Double) не учитывается при выборе перегруженного метода.

**При прямых вызовах (2):**
Компилятор видит точный тип каждого аргумента:
- `new Integer(1)` → тип `Integer` → вызывается `printNum(Integer i)`
- `11` → тип `int` → вызывается `printNum(int i)`
- `1.11f` → тип `float` → автоупаковка в `Float` → вызывается `printNum(Float f)`
- `11.11` → тип `double` → автоупаковка в `Double` → нет метода для `Double`, используется `printNum(Number n)`

## Ключевой момент

Перегрузка (overloading) — **статический полиморфизм**. Решение о том, какой метод вызвать, принимается компилятором на основе **типа переменной**, а не реального типа объекта.

Переопределение (override) — **динамический полиморфизм**. Решение принимается во время выполнения на основе реального типа объекта.
