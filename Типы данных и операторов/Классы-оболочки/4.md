### Практика 4:  — Анализ кода с Integer
```java
int i1 = 128;
Integer a1 = i1;
Integer b1 = i1;
System.out.println("a1==i1 " + (a1 == i1));
System.out.println("b1==i1 " + (b1 == i1));
System.out.println("a1==b1 " + (a1 == b1));
System.out.println("a1.equals(i1) -> " + a1.equals(i1));
System.out.println("b1.equals(i1) -> " + b1.equals(i1));
System.out.println("a1.equals(b1) -> " + a1.equals(b1));

int i2 = 127;
Integer a2 = i2;
Integer b2 = i2;
System.out.println("a2==i2 " + (a2 == i2));
System.out.println("b2==i2 " + (b2 == i2));
System.out.println("a2==b2 " + (a2 == b2));
System.out.println("a2.equals(i2) -> " + a2.equals(i2));
System.out.println("b2.equals(i2) -> " + b2.equals(i2));
System.out.println("a2.equals(b2) -> " + a2.equals(b2));
```
Результат:
```text
a1==i1 true
b1==i1 true
a1==b1 false
a1.equals(i1) -> true
b1.equals(i1) -> true
a1.equals(b1) -> true

a2==i2 true
b2==i2 true
a2==b2 true
a2.equals(i2) -> true
b2.equals(i2) -> true
a2.equals(b2) -> true
```
### Объяснение
Для `i1 = 128`:

`a1 == i1 → true` — при сравнении с примитивом происходит автораспаковка, сравниваются значения
`b1 == i1 → true` — аналогично
`a1 == b1 → false` — сравниваются ссылки на разные объекты (128 вне кэша)
`equals() → true` — сравниваются значения

Для `i2 = 127`:

`a2 == i2 → true` — автораспаковка, сравниваются значения
`b2 == i2 → true` — аналогично
`a2 == b2 → true` — ссылки указывают на один и тот же закэшированный объект
`equals() → true` — сравниваются значения

*IntegerCache* — внутренний класс в Integer, который кэширует объекты Integer для значений от -128 до 127 включительно.

При автоупаковке значений из этого диапазона Java возвращает один и тот же объект из кэша, а не создаёт новый. Поэтому:

 - Для 127: a2 и b2 ссылаются на один объект из кэша → `a2 == b2` даёт `true`
 - Для 128: создаются разные объекты → `a1 == b1` даёт `false`

Это сделано для оптимизации памяти, так как небольшие числа используются очень часто.
